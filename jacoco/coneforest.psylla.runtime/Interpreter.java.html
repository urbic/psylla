<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Interpreter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Psylla v0.22.1</a> &gt; <a href="index.source.html" class="el_package">coneforest.psylla.runtime</a> &gt; <span class="el_source">Interpreter.java</span></div><h1>Interpreter.java</h1><pre class="source lang-java linenums">package coneforest.psylla.runtime;

import coneforest.psylla.core.*;
import coneforest.psylla.runtime.parser.Parser;
import coneforest.psylla.runtime.parser.ParserConstants;
import coneforest.psylla.runtime.parser.Token;
import coneforest.psylla.runtime.parser.TokenMgrError;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.StringJoiner;
import jline.ConsoleReader;

/**
*	The Psylla language interpreter.
*/
public class Interpreter
	//extends Thread
	implements PsyContext
{
	protected DictStack dstack;
	private final OperandStack ostack;
	private final ExecutionStack estack;
	private final ProcStack procstack;
<span class="fc" id="L34">	private final HashMap&lt;String, String&gt; resourceRegistry=new HashMap&lt;&gt;();</span>
<span class="fc" id="L35">	private final NamespacePool nspool=new NamespacePool();</span>
	//private final Thread thread=Thread.ofVirtual().unstarted(this);
<span class="fc" id="L37">	private final Thread thread=Thread.ofPlatform().unstarted(this);</span>
	/*private final Thread thread=new Thread()
		{
			@Override
			public void run()
			{
				Interpreter.this.run();
			}
		};*/

<span class="fc" id="L47">	private boolean stopped=false;</span>
<span class="fc" id="L48">	private boolean running=true;</span>

<span class="fc" id="L50">	private final ClassLoader classLoader=new DynamicClassLoader()</span>
<span class="fc" id="L51">		{</span>
			@Override
			protected Iterable&lt;String&gt; getClassPath()
				throws PsyUndefinedException
			{
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L57">				final var parentIterator</span>
<span class="fc" id="L58">					=((PsyFormalArray&lt;PsyTextual&gt;)systemDict().get(&quot;classpath&quot;)).iterator();</span>
<span class="fc" id="L59">				return new Iterable&lt;String&gt;()</span>
<span class="fc" id="L60">					{</span>
						@Override
						public Iterator&lt;String&gt; iterator()
						{
<span class="fc" id="L64">							return new Iterator&lt;String&gt;()</span>
<span class="fc" id="L65">								{</span>
									@Override
									public boolean hasNext()
									{
<span class="fc" id="L69">										return parentIterator.hasNext();</span>
									}

									@Override
									public String next()
									{
<span class="nc" id="L75">										return parentIterator.next().stringValue();</span>
									}
								};
						}
					};
			}
		};

	/**
	*	Creates a new Psylla language interpreter.
	*/
	public Interpreter()
<span class="fc" id="L87">	{</span>
		try
		{
<span class="fc" id="L90">			ostack=new OperandStack();</span>
<span class="fc" id="L91">			estack=new ExecutionStack();</span>
<span class="fc" id="L92">			procstack=new ProcStack();</span>
<span class="fc" id="L93">			dstack=new DictStack();</span>
		}
<span class="nc" id="L95">		catch(final PsyErrorException e)</span>
		{
			// TODO more appropriate exception
<span class="nc" id="L98">			throw new AssertionError(e);</span>
<span class="fc" id="L99">		}</span>
<span class="fc" id="L100">	}</span>

	@Override
	public void fork()
		throws PsyStackUnderflowException, PsyUnmatchedMarkException
	{
<span class="fc" id="L106">		final var ostack=operandStackBacked(1);</span>
<span class="fc" id="L107">		final var o=ostack.getBacked(0);</span>
<span class="fc" id="L108">		final var forkedDstack=dstack.clone();</span>
<span class="fc" id="L109">		final var oForkedContext=new Interpreter()</span>
<span class="fc" id="L110">			{</span>
				{
<span class="fc" id="L112">					dstack=forkedDstack;</span>
<span class="fc" id="L113">				}</span>

				@Override
				public void run()
				{
<span class="fc" id="L118">					o.invoke(this);</span>
<span class="fc" id="L119">					handleExecutionStack(0);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">					if(getStopped())</span>
<span class="nc" id="L121">						return;</span>
<span class="fc" id="L122">				}</span>
			};
<span class="fc" id="L124">		final int i=ostack.findMarkPosition();</span>
<span class="fc" id="L125">		final int ostackSize=ostack.size();</span>
<span class="fc" id="L126">		final var forkedOstack=oForkedContext.operandStack();</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">		for(int j=i+1; j&lt;ostackSize; j++)</span>
<span class="fc" id="L128">			forkedOstack.push(ostack.get(j));</span>
<span class="fc" id="L129">		ostack.setSize(i);</span>
<span class="fc" id="L130">		ostack.push(oForkedContext);</span>
<span class="fc" id="L131">		oForkedContext.start();</span>
<span class="fc" id="L132">	}</span>

	/*public void importType(final String typeName)
		throws PsyErrorException
	{
		PsyNamespace.namespace(&quot;system&quot;).psyImport(PsyNamespace.namespace(TypeResolver.resolve(typeName)));
	}*/

	@Override
	public OperandStack operandStack()
	{
<span class="fc" id="L143">		return ostack;</span>
	}

	@Override
	public OperandStack operandStackBacked(final int count)
		throws PsyStackUnderflowException
	{
<span class="fc" id="L150">		ostack.popOperands(count);</span>
<span class="fc" id="L151">		return ostack;</span>
	}

	@Override
	public DictStack dictStack()
	{
<span class="fc" id="L157">		return dstack;</span>
	}

	@Override
	public ExecutionStack executionStack()
	{
<span class="fc" id="L163">		return estack;</span>
	}

	/**
	*	{@return the interpreter’s class loader}
	*/
	public ClassLoader classLoader()
	{
<span class="nc" id="L171">		return classLoader;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	protected &lt;T extends PsyObject&gt; T load(final String name)
		throws PsyUndefinedException
	{
<span class="fc" id="L178">		final var prefixOffset=name.indexOf('@');</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">		if(prefixOffset==-1)</span>
<span class="fc" id="L180">			return dstack.&lt;T&gt;load(name);</span>
<span class="fc" id="L181">		return (T)nspool.get(name.substring(0, prefixOffset))</span>
<span class="fc" id="L182">				.get(name.substring(prefixOffset+1));</span>
	}

	@Override
	public &lt;T extends PsyObject&gt; T psyLoad(final PsyTextual oKey)
		throws PsyUndefinedException
	{
<span class="fc" id="L189">		return this.&lt;T&gt;load(oKey.stringValue());</span>
	}

	@Override
	public void handleExecutionStack(final int level)
	{
<span class="fc bfc" id="L195" title="All 2 branches covered.">		while(estack.size()&gt;level)</span>
<span class="fc" id="L196">			estack.pop().execute(this);</span>
<span class="fc" id="L197">	}</span>

	@Override
	public PsyFormalDict&lt;PsyObject&gt; /*&lt;? extends PsyObject&gt;*/ currentDict()
	{
<span class="fc" id="L202">		return dstack.peek();</span>
	}

	@Override
	public PsyFormalDict&lt;PsyObject&gt; /*&lt;? extends PsyObject&gt;*/ systemDict()
	{
<span class="fc" id="L208">		return dstack.get(0);</span>
	}

	@Override
	public PsyFormalDict&lt;PsyObject&gt; /*&lt;? extends PsyObject&gt;*/ userDict()
	{
<span class="nc" id="L214">		return dstack.get(1);</span>
	}

	@Override
	public NamespacePool namespacePool()
	{
<span class="fc" id="L220">		return nspool;</span>
	}

	/**
	*	{@return the current namespace}
	*/
	public PsyNamespace currentNamespace()
	{
<span class="nc" id="L228">		return dstack.currentNamespace();</span>
	}

	/**
	*	Sets the interpreter’s standard reader.
	*
	*	@param reader the reader.
	*/
	public void setReader(final Reader reader)
	{
<span class="nc" id="L238">		systemDict().put(&quot;stdin&quot;, new PsyReader(reader));</span>
<span class="nc" id="L239">	}</span>

	/**
	*	Sets the interpreter’s standard writer.
	*
	*	@param writer the writer.
	*/
	public void setWriter(final Writer writer)
	{
<span class="fc" id="L248">		systemDict().put(&quot;stdout&quot;, new PsyWriter(writer));</span>
<span class="fc" id="L249">	}</span>

	/**
	*	Sets the interpreter’s standard error writer.
	*
	*	@param writer the error writer.
	*/
	public void setErrorWriter(final Writer writer)
	{
<span class="fc" id="L258">		systemDict().put(&quot;stderr&quot;, new PsyWriter(writer));</span>
<span class="fc" id="L259">	}</span>

	/**
	*	Reseeds the interpreter’s standard pseudorandom generator, using the given seed.
	*
	*	@param randomSeed the seed.
	*	@throws PsyUndefinedException when TODO
	*/
	public void setRandomSeed(final Long randomSeed)
		throws PsyUndefinedException
	{
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">		if(randomSeed!=null)</span>
<span class="nc" id="L271">			((PsyRandom)systemDict().get(&quot;stdrandom&quot;))</span>
<span class="nc" id="L272">					.psySetSeed(PsyInteger.of(randomSeed));</span>
<span class="fc" id="L273">	}</span>

	public void setClassPath(final String[] classPath)
		throws
			PsyLimitCheckException,
			PsyRangeCheckException,
			PsyUndefinedException
	{
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L282">		final var oClassPath</span>
<span class="fc" id="L283">			=(PsyFormalArray&lt;PsyTextual&gt;)systemDict().get(&quot;classpath&quot;);</span>
<span class="fc" id="L284">		final var envClassPath=System.getenv(&quot;PSYLLA_CLASSPATH&quot;);</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">		if(envClassPath!=null)</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">			for(final var pathItem: envClassPath.split(File.pathSeparator))</span>
<span class="nc" id="L287">				oClassPath.psyAppend(new PsyString(pathItem));</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">		if(classPath!=null)</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">			for(final var pathItem: classPath)</span>
<span class="nc" id="L290">				oClassPath.psyAppend(new PsyString(pathItem));</span>
<span class="fc" id="L291">	}</span>

	public void setLibraryPath(final String[] libraryPath)
		throws
			PsyLimitCheckException,
			PsyRangeCheckException,
			PsyUndefinedException
	{
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L300">		final var oLibraryPath</span>
<span class="fc" id="L301">			=(PsyFormalArray&lt;PsyTextual&gt;)systemDict().get(&quot;librarypath&quot;);</span>
<span class="fc" id="L302">		final var envLibraryPath=System.getenv(&quot;PSYLLA_LIBRARYPATH&quot;);</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">		if(envLibraryPath!=null)</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">			for(final var pathItem: envLibraryPath.split(File.pathSeparator))</span>
<span class="nc" id="L305">				oLibraryPath.psyAppend(new PsyString(pathItem));</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">		if(libraryPath!=null)</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">			for(final var pathItem: libraryPath)</span>
<span class="fc" id="L308">				oLibraryPath.psyAppend(new PsyString(pathItem));</span>
<span class="fc" id="L309">	}</span>

	public void interpret(final Reader reader)
	{
<span class="fc" id="L313">		interpret(new PsyReader(reader));</span>
<span class="fc" id="L314">	}</span>

	public void interpret(final String string)
	{
<span class="nc" id="L318">		interpret(new PsyStringReader(string));</span>
<span class="nc" id="L319">	}</span>

	@Override
	public void interpret(final PsyReader oReader)
	{
<span class="fc" id="L324">		final var initProcLevel=procstack.size();</span>
<span class="fc" id="L325">		final var parser=new Parser(oReader);</span>
		try
		{
<span class="fc bfc" id="L328" title="All 2 branches covered.">			while(running)</span>
			{
<span class="fc" id="L330">				final var token=parser.getNextToken();</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">				if(token.kind==ParserConstants.EOF)</span>
<span class="fc" id="L332">					break;</span>
<span class="fc" id="L333">				processToken(token);</span>

				// If &quot;stop&quot; is invoked outside an explicit stopping context
<span class="fc bfc" id="L336" title="All 2 branches covered.">				if(getStopped())</span>
<span class="fc" id="L337">					return;</span>
<span class="fc" id="L338">			}</span>
			// Incomplete procedure read
<span class="fc bfc" id="L340" title="All 2 branches covered.">			if(procstack.size()&gt;initProcLevel)</span>
			{
<span class="fc" id="L342">				final var e=new PsySyntaxErrorException();</span>
<span class="fc" id="L343">				e.setEmitter(oReader);</span>
<span class="fc" id="L344">				throw e;</span>
			}

<span class="fc" id="L347">			dstack.&lt;PsyFlushable&gt;load(&quot;stdout&quot;).psyFlush();</span>
<span class="fc" id="L348">			dstack.&lt;PsyFlushable&gt;load(&quot;stderr&quot;).psyFlush();</span>
		}
<span class="fc" id="L350">		catch(final PsyErrorException e)</span>
		{
<span class="fc" id="L352">			e.setEmitter(oReader); // IMPORTANT</span>
<span class="fc" id="L353">			e.setStacks(ostack, estack, dstack);</span>
<span class="fc" id="L354">			e.invoke(this);</span>
		}
<span class="fc" id="L356">		catch(final TokenMgrError ex)</span>
		{
<span class="fc" id="L358">			final var e=new PsySyntaxErrorException();</span>
<span class="fc" id="L359">			e.setEmitter(oReader);</span>
<span class="fc" id="L360">			e.setStacks(ostack, estack, dstack);</span>
<span class="fc" id="L361">			e.invoke(this);</span>
<span class="fc" id="L362">		}</span>
<span class="fc" id="L363">	}</span>

	@Override
	public void interpretBraced(final PsyReader oReader)
		throws PsyLimitCheckException
	{
<span class="nc" id="L369">		procstack.push(new PsyProc());</span>
<span class="nc" id="L370">		interpret(oReader);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">		if(procstack.size()==0)</span>
		{
<span class="nc" id="L373">			final var e=new PsySyntaxErrorException();</span>
<span class="nc" id="L374">			e.setEmitter(oReader);</span>
<span class="nc" id="L375">			e.setStacks(ostack, estack, dstack);</span>
<span class="nc" id="L376">			e.invoke(this);</span>
		}
<span class="nc" id="L378">		final var proc=procstack.pop();</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if(procstack.size()&gt;0)</span>
<span class="nc" id="L380">			procstack.peek().psyAppend(proc);</span>
		else
<span class="nc" id="L382">			ostack.push(proc);</span>
<span class="nc" id="L383">	}</span>

	private void processToken(final Token token)
		throws
			PsyInvalidRegExpException,
			PsyLimitCheckException,
			PsySyntaxErrorException,
			PsyUndefinedException
	{
<span class="fc bfc" id="L392" title="All 2 branches covered.">		if(procstack.size()==0)</span>
		{
<span class="fc bfc" id="L394" title="All 5 branches covered.">			switch(token.kind)</span>
			{
				case ParserConstants.NAME-&gt;
					{
<span class="fc" id="L398">						parseToken(token).execute(this);</span>
<span class="fc" id="L399">						handleExecutionStack(0);</span>
<span class="fc" id="L400">					}</span>
				case ParserConstants.INTEGRAL,
						ParserConstants.REAL,
						ParserConstants.STRING,
						ParserConstants.STRINGBUFFER,
						ParserConstants.IMMEDIATE,
						ParserConstants.REGEXP,
						ParserConstants.LITERAL-&gt;
<span class="fc" id="L408">					ostack.push(parseToken(token));</span>
				case ParserConstants.OPEN_BRACE-&gt;
<span class="fc" id="L410">					procstack.push(new PsyProc());</span>
				case ParserConstants.CLOSE_BRACE-&gt;
<span class="fc" id="L412">					throw new PsySyntaxErrorException();</span>
<span class="fc" id="L413">				case ParserConstants.EOF-&gt;{}</span>
			}
		}
		else
		{
<span class="pc bpc" id="L418" title="2 of 5 branches missed.">			switch(token.kind)</span>
			{
				case ParserConstants.OPEN_BRACE-&gt;
<span class="fc" id="L421">					procstack.push(new PsyProc());</span>
				case ParserConstants.CLOSE_BRACE-&gt;
					{
<span class="fc" id="L424">						final var proc=procstack.pop();</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">						if(procstack.size()&gt;0)</span>
<span class="fc" id="L426">							procstack.peek().psyAppend(proc);</span>
						else
<span class="fc" id="L428">							ostack.push(proc);</span>
<span class="fc" id="L429">					}</span>
				case ParserConstants.INTEGRAL,
						ParserConstants.REAL,
						ParserConstants.NAME,
						ParserConstants.STRING,
						ParserConstants.STRINGBUFFER,
						ParserConstants.IMMEDIATE,
						ParserConstants.REGEXP,
						ParserConstants.LITERAL
<span class="fc" id="L438">					-&gt;procstack.peek().psyAppend(parseToken(token));</span>
				case ParserConstants.EOF-&gt;
<span class="nc" id="L440">					throw new PsySyntaxErrorException();</span>
			}
		}
<span class="fc" id="L443">	}</span>

	private PsyObject parseToken(final Token token)
		throws
			PsyInvalidRegExpException,
			PsySyntaxErrorException,
			PsyUndefinedException
	{
<span class="fc" id="L451">		final var image=token.image;</span>
<span class="pc bpc" id="L452" title="2 of 9 branches missed.">		return switch(token.kind)</span>
			{
<span class="fc" id="L454">				case ParserConstants.IMMEDIATE-&gt;dstack.load(image.substring(2));</span>
<span class="fc" id="L455">				case ParserConstants.STRING-&gt;PsyString.parseLiteral(image);</span>
<span class="fc" id="L456">				case ParserConstants.INTEGRAL-&gt;PsyIntegral.parseLiteral(image);</span>
<span class="fc" id="L457">				case ParserConstants.REAL-&gt;PsyReal.parseLiteral(image);</span>
<span class="fc" id="L458">				case ParserConstants.STRINGBUFFER-&gt;PsyStringBuffer.parseLiteral(image);</span>
<span class="fc" id="L459">				case ParserConstants.REGEXP-&gt;PsyRegExp.parseLiteral(image);</span>
<span class="fc" id="L460">				case ParserConstants.NAME-&gt;new PsyName(image);</span>
<span class="nc" id="L461">				case ParserConstants.LITERAL-&gt;parseLiteralImage(image);</span>
<span class="nc" id="L462">				default-&gt;throw new AssertionError();	// TODO more appropriate exception</span>
			};
	}

	private PsyObject parseLiteralImage(final String image)
		throws
			PsyUndefinedException, // TODO
			PsySyntaxErrorException
	{
<span class="nc" id="L471">		final int i=image.indexOf('=');</span>
<span class="nc" id="L472">		final var typeName=image.substring(0, i);</span>
<span class="nc" id="L473">		final var typeClass=TypeResolver.resolve(typeName);</span>
		try
		{
<span class="nc" id="L476">			final var mh=MethodHandles.lookup().findStatic(</span>
					typeClass,
					&quot;parseLiteral&quot;,
<span class="nc" id="L479">					MethodType.methodType(typeClass, String.class));</span>
<span class="nc" id="L480">			return typeClass.cast(mh.invoke(image.substring(i+2, image.length()-1)));</span>
		}
<span class="nc" id="L482">		catch(final NoSuchMethodException|IllegalAccessException ex)</span>
		{
<span class="nc" id="L484">			throw new PsyUndefinedException();	// TODO more appropriate exception</span>
		}
<span class="nc" id="L486">		catch(final Throwable ex)</span>
		{
<span class="nc" id="L488">			throw new PsySyntaxErrorException();</span>
		}
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public PsyFormalDict&lt;PsyObject&gt; errorDict()
		throws PsyUndefinedException
	{
<span class="nc" id="L496">		return (PsyFormalDict&lt;PsyObject&gt;)systemDict().get(&quot;errordict&quot;);</span>
		//return PsyNamespace.namespace(&quot;errordict&quot;);
	}

	/*
	@Override
	public void handleError(final PsyErrorException oException)
	{
		final var errorName=oException.getName();
		final var errorObj=new PsyDict();
		errorObj.put(&quot;newerror&quot;, PsyBoolean.TRUE);
		errorObj.put(&quot;errorname&quot;, new PsyString(errorName));
		errorObj.put(&quot;emitter&quot;, oException.getEmitter());
		errorObj.put(&quot;ostack&quot;, new PsyArray((ArrayList&lt;PsyObject&gt;)ostack.clone()));
		errorObj.put(&quot;estack&quot;, new PsyArray((ArrayList&lt;PsyObject&gt;)estack.clone()));
		errorObj.put(&quot;dstack&quot;, new PsyArray((ArrayList&lt;PsyObject&gt;)dstack.clone()));
		systemDict().put(&quot;$error&quot;, errorObj);

		try
		{
			final var errorDict=errorDict();
			if(errorDict.known(errorName))
				errorDict.get(errorName).invoke(this);
			else
				stop_();
		}
		catch(final PsyErrorException e)
		{
			throw new AssertionError(e);
		}
	}
	*/

	@Override
	public void showStacks()
	{
<span class="fc" id="L532">		System.err.print(Messages.getString(&quot;handleErrorMessageOStack&quot;));</span>
		{
<span class="fc" id="L534">			final var sj=new StringJoiner(&quot; &quot;, &quot;\n\t&quot;, &quot;&quot;);</span>
<span class="fc" id="L535">			sj.setEmptyValue(&quot; &quot;+Messages.getString(&quot;handleErrorMessageEmpty&quot;));</span>
<span class="fc" id="L536">			ostack.forEach(o-&gt;sj.add(o.toSyntaxString()));</span>
<span class="fc" id="L537">			System.err.println(sj.toString());</span>
		}

<span class="fc" id="L540">		System.err.print(Messages.getString(&quot;handleErrorMessageEStack&quot;));</span>
		{
<span class="fc" id="L542">			final var sj=new StringJoiner(&quot; &quot;, &quot;\n\t&quot;, &quot;&quot;);</span>
<span class="fc" id="L543">			sj.setEmptyValue(&quot; &quot;+Messages.getString(&quot;handleErrorMessageEmpty&quot;));</span>
<span class="pc" id="L544">			estack.forEach(o-&gt;sj.add(o.toSyntaxString()));</span>
<span class="fc" id="L545">			System.err.println(sj.toString());</span>
		}
<span class="fc" id="L547">	}</span>

	@Override
	public int execLevel()
	{
<span class="fc" id="L552">		return estack.size();</span>
	}

	@Override
	public boolean getStopped()
	{
<span class="fc" id="L558">		return stopped;</span>
	}

	@Override
	public void setStopped(final boolean stopped)
	{
<span class="fc" id="L564">		this.stopped=stopped;</span>
<span class="fc" id="L565">	}</span>

	public void setScriptName(final String scriptName)
	{
<span class="fc" id="L569">		systemDict().put(&quot;script&quot;, new PsyString(scriptName));</span>
<span class="fc" id="L570">	}</span>

	public void setShellArguments(final String[] args)
		throws PsyLimitCheckException, PsyUndefinedException
	{
<span class="fc" id="L575">		final var oArguments=(PsyArray)systemDict().get(&quot;arguments&quot;);</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">		for(final var arg: args)</span>
<span class="nc" id="L577">			oArguments.psyAppend(new PsyString(arg));</span>
<span class="fc" id="L578">	}</span>

	public void setEnvironment(final Map&lt;String, String&gt; env)
	{
<span class="fc" id="L582">		systemDict().put(&quot;environment&quot;, new PsyEnvironment(env));</span>
<span class="fc" id="L583">	}</span>

	@Override
	public void quit()
	{
<span class="fc" id="L588">		running=stopped=false;</span>
<span class="fc" id="L589">		estack.clear();</span>
<span class="fc" id="L590">	}</span>

	@Override
	public void repl()
		throws PsyIOErrorException
	{
		try
		{
<span class="nc" id="L598">			final var cr=new ConsoleReader();</span>
<span class="nc" id="L599">			cr.printString(banner());</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">			while(running)</span>
			{
<span class="nc" id="L602">				cr.setDefaultPrompt(prompt());</span>
<span class="nc" id="L603">				final var line=cr.readLine();</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">				if(line==null)</span>
				{
<span class="nc" id="L606">					cr.printNewline();</span>
<span class="nc" id="L607">					cr.flushConsole();</span>
<span class="nc" id="L608">					return;</span>
				}
<span class="nc" id="L610">				final var oReader=new PsyReader(new StringReader(line));</span>
<span class="nc" id="L611">				final var parser=new Parser(oReader);</span>
				try
				{
<span class="nc bnc" id="L614" title="All 2 branches missed.">					while(running)</span>
					{
<span class="nc" id="L616">						final var token=parser.getNextToken();</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">						if(token.kind==ParserConstants.EOF)</span>
<span class="nc" id="L618">							break;</span>
<span class="nc" id="L619">						processToken(token);</span>
						// If &quot;stop&quot; invoked outside an explicit stopping context
<span class="nc bnc" id="L621" title="All 2 branches missed.">						if(getStopped())</span>
						{
<span class="nc" id="L623">							setStopped(false);</span>
<span class="nc" id="L624">							break;</span>
						}
<span class="nc" id="L626">					}</span>
				}
<span class="nc" id="L628">				catch(final PsyErrorException e)</span>
				{
<span class="nc" id="L630">					e.setEmitter(oReader);</span>
<span class="nc" id="L631">					e.setStacks(ostack, estack, dstack);</span>
<span class="nc" id="L632">					e.invoke(this);</span>
				}
<span class="nc" id="L634">				catch(final TokenMgrError ex)</span>
				{
<span class="nc" id="L636">					final var e=new PsySyntaxErrorException();</span>
<span class="nc" id="L637">					e.setEmitter(oReader);</span>
<span class="nc" id="L638">					e.setStacks(ostack, estack, dstack);</span>
<span class="nc" id="L639">					e.invoke(this);</span>
<span class="nc" id="L640">				}</span>
<span class="nc" id="L641">			}</span>
		}
<span class="nc" id="L643">		catch(final IOException ex)</span>
		{
<span class="nc" id="L645">			throw new PsyIOErrorException();</span>
<span class="nc" id="L646">		}</span>
<span class="nc" id="L647">	}</span>

	/**
	*	{@return the Psylla banner}
	*/
	protected String banner()
	{
<span class="nc" id="L654">		return String.format(Messages.getString(&quot;banner&quot;), Version.getVersion());</span>
	}

	/**
	*	{@return the REPL prompt}
	*/
	public String prompt()
	{
<span class="nc" id="L662">		final var sb=new StringBuilder(&quot;PSYLLA&quot;);</span>
<span class="nc" id="L663">		sb.append(&quot;{&quot;.repeat(procstack.size()));</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">		if(ostack.size()&gt;0)</span>
<span class="nc" id="L665">			sb.append(&quot;&lt;&quot;+ostack.size());</span>
<span class="nc" id="L666">		sb.append(&quot;&gt; &quot;);</span>
<span class="nc" id="L667">		return sb.toString();</span>
	}

	public void start()
	{
<span class="fc" id="L672">		thread.start();</span>
		//thread=Thread.startVirtualThread(this::run);
<span class="fc" id="L674">	}</span>

	@Override
	public void run()
	{
<span class="nc" id="L679">	}</span>

	@Override
	public void join()
		throws InterruptedException
	{
<span class="fc" id="L685">		thread.join();</span>
<span class="fc" id="L686">	}</span>

	//@Override
	public void join(final long millis)
		throws InterruptedException
	{
<span class="nc" id="L692">		thread.join(millis);</span>
<span class="nc" id="L693">	}</span>

	@Override
	public long getId()
	{
<span class="nc" id="L698">		return thread.threadId();</span>
	}

	@Override
	public void stop_()
	{
<span class="fc" id="L704">		setStopped(true);</span>
<span class="fc" id="L705">		estack.exitStop();	// TODO quit()</span>
<span class="fc" id="L706">	}</span>

	public boolean loadLibraryResource(final String resourceName)
		throws
			PsyFileAccessDeniedException,
			PsyFileNotFoundException,
			PsyIOErrorException,
			PsySecurityErrorException,
			PsyUndefinedException,
			PsyErrorException	// TODO
	{
<span class="fc" id="L717">		final var oLibraryPath=dstack.&lt;PsyFormalArray&lt;PsyTextual&gt;&gt;load(&quot;librarypath&quot;);</span>
<span class="fc" id="L718">		final var filePath=resourceName.replace('.', '/');</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">		for(final var oPathItem: oLibraryPath)</span>
		{
<span class="fc" id="L721">			final var oFullResourceName</span>
<span class="fc" id="L722">				=new PsyString(oPathItem.stringValue()+'/'+filePath+&quot;.psy&quot;);</span>
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">			if(PsyFileSystem.psyFileExists(oFullResourceName).booleanValue()</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">					&amp;&amp; PsyFileSystem.psyIsFile(oFullResourceName).booleanValue())</span>
			{
<span class="fc" id="L726">				final var resourceID</span>
<span class="fc" id="L727">					=&quot;file:&quot;+PsyFileSystem.psyFileAbsolutePath(oFullResourceName).stringValue();</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">				if(resourceRegistry.containsKey(resourceName))</span>
					// TODO
<span class="nc" id="L730">					System.out.println(&quot;Already loaded: &quot;+resourceID);</span>
				else
				{
<span class="fc" id="L733">					resourceRegistry.put(resourceName, resourceID);</span>
<span class="fc" id="L734">					new PsyFileReader(oFullResourceName).psyEval(this);</span>
				}
<span class="fc" id="L736">				return true;</span>
			}
<span class="nc" id="L738">		}</span>
<span class="nc" id="L739">		return false;</span>
	}

	/*
	public void loadAnnotatedOperators(final Class&lt;PsyObject&gt; clazz)
	{
		for(final var method: clazz.getDeclaredMethods())
			if(method.isAnnotationPresent(Operator.class))
			{
				final var oOperator=new PsyOperator.Method(method);
				nspool.get(oOperator.getPrefix()).put(oOperator.getSimpleName(), oOperator);
				//oNamespace.put(method.getDeclaredAnnotation(Operator.class).value(),
				//		PsyOperator.of(method));
			}
		//
		for(final var constructor: clazz.getDeclaredConstructors())
			if(constructor.isAnnotationPresent(Operator.class))
				oNamespace.put(constructor.getDeclaredAnnotation(Operator.class).value(),
						PsyOperator.of(constructor));
		//
	}
	*/

	public boolean loadType(final String typeName)
	{
		// TODO check NPE at readLine
		try
		{
<span class="fc" id="L767">			final var resourceStream=classLoader.getResourceAsStream(</span>
					&quot;META-INF/psylla/type/&quot;+typeName);
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">			if(resourceStream==null)</span>
<span class="fc" id="L770">				return false;</span>
<span class="nc" id="L771">			final var className=(new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L772">					resourceStream))).readLine();</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">			if(className==null)</span>
<span class="nc" id="L774">				return false;</span>
<span class="nc" id="L775">			final var clazz=Class.forName(</span>
<span class="nc" id="L776">				className, true, classLoader).asSubclass(PsyObject.class);</span>
<span class="nc" id="L777">			final var resourceID=&quot;class:&quot;+clazz.getName();</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">			if(resourceRegistry.containsKey(typeName))</span>
			{
<span class="nc" id="L780">				System.out.println(&quot;Already loaded: &quot;+resourceID);</span>
<span class="nc" id="L781">				return true;</span>
			}
			else
<span class="nc" id="L784">				resourceRegistry.put(typeName, resourceID);</span>
			//final var oNamespace=PsyNamespace.namespace(clazz.getAnnotation(Type.class).value());
			/*
			for(final var method: clazz.getDeclaredMethods())
			{
				if(method.isAnnotationPresent(Operator.class))
				{
					final var operatorName=method.getDeclaredAnnotation(Operator.class).value();
					oNamespace.put(operatorName, PsyOperator.of(method));
				}
			}
			for(final var constructor: clazz.getDeclaredConstructors())
			{
				if(constructor.isAnnotationPresent(Operator.class))
				{
					final var operatorName=constructor.getDeclaredAnnotation(Operator.class).value();
					oNamespace.put(operatorName, PsyOperator.of(constructor));
				}
			}
			for(final var field: clazz.getDeclaredFields())
			{
				if(field.isAnnotationPresent(Operator.class))
				{
					System.out.println(&quot;FIELD&quot;);
					final var operatorName=field.getDeclaredAnnotation(Operator.class).value();
					oNamespace.put(operatorName, (PsyOperator)field.get(null));
				}
			}
			*/
			/*
			for(final var field: clazz.getDeclaredFields())
			{
				if(field.isAnnotationPresent(Export.class))
				{
					//System.out.println(&quot;FIELD&quot;);
					//final var operatorName=field.getDeclaredAnnotation(Operator.class).value();
					//oNamespace.put(operatorName, (PsyOperator)field.get(null));
					final var operators=(PsyOperator[])field.get(null);
					for(final var oOperator: operators)
					{
						//System.out.println(oOperator.getName());
						systemDict().put(oOperator.getName(), oOperator);
					}

				}
			}
			*/
<span class="nc" id="L831">			return true;</span>
		}
		//catch(IOException|ClassNotFoundException|NullPointerException|IllegalAccessException e)
<span class="nc" id="L834">		catch(final IOException|ClassNotFoundException ex)</span>
		{
<span class="nc" id="L836">			return false;</span>
		}
	}

	@Override
	public void psyRequire(final PsyTextual oResourceName)
		throws
			PsyFileAccessDeniedException,
			PsyFileNotFoundException,
			PsyIOErrorException,
			PsySecurityErrorException,
			PsyUndefinedException,
			PsyErrorException	// TODO
	{
<span class="fc" id="L850">		final var resourceName=oResourceName.stringValue();</span>

<span class="pc bpc" id="L852" title="1 of 2 branches missed.">		if(loadType(resourceName))</span>
<span class="nc" id="L853">			return;</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">		if(loadLibraryResource(resourceName))</span>
<span class="fc" id="L855">			return;</span>
<span class="nc" id="L856">		throw new PsyUndefinedException(); // TODO: more appropriate exception</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202410190809</span></div></body></html>