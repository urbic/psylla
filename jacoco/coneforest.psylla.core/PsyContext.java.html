<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PsyContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Psylla v0.22.1</a> &gt; <a href="index.source.html" class="el_package">coneforest.psylla.core</a> &gt; <span class="el_source">PsyContext.java</span></div><h1>PsyContext.java</h1><pre class="source lang-java linenums">package coneforest.psylla.core;

import coneforest.psylla.runtime.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Optional;
import jline.ConsoleReader;

/**
*	The representation of {@code context}, an execution context.
*/
@Type(&quot;context&quot;)
public interface PsyContext
	extends PsyObject, Runnable
{
	/**
	*	Context action of the {@code begin} operator.
	*/
	@OperatorType(&quot;begin&quot;)
<span class="fc" id="L20">	public static final ContextAction PSY_BEGIN=oContext-&gt;</span>
		{
<span class="fc" id="L22">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L23">			oContext.dictStack().begin(ostack.getBacked(0));</span>
<span class="fc" id="L24">		};</span>

	/**
	*	Context action of the {@code cleardictstack} operator.
	*/
	@OperatorType(&quot;cleardictstack&quot;)
<span class="fc" id="L30">	public static final ContextAction PSY_CLEARDICTSTACK=oContext-&gt;oContext.dictStack().setSize(2);</span>

	/**
	*	Context action of the {@code clearstack} operator.
	*/
	@OperatorType(&quot;clearstack&quot;)
<span class="fc" id="L36">	public static final ContextAction PSY_CLEARSTACK=oContext-&gt;oContext.operandStack().clear();</span>

	/**
	*	Context action of the {@code cleartomark} operator.
	*/
	@OperatorType(&quot;cleartomark&quot;)
<span class="fc" id="L42">	public static final ContextAction PSY_CLEARTOMARK=oContext-&gt;</span>
		{
<span class="fc" id="L44">			final var ostack=oContext.operandStack();</span>
<span class="fc" id="L45">			ostack.setSize(ostack.findMarkPosition());</span>
<span class="fc" id="L46">		};</span>

	/**
	*	Context action of the {@code copy} operator.
	*/
	@OperatorType(&quot;copy&quot;)
<span class="fc" id="L52">	public static final ContextAction PSY_COPY=oContext-&gt;</span>
		{
<span class="fc" id="L54">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L55">			final int count=ostack.&lt;PsyInteger&gt;getBacked(0).intValue();</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">			if(count&lt;0)</span>
<span class="fc" id="L57">				throw new PsyRangeCheckException();</span>
<span class="fc" id="L58">			ostack.ensureSize(count);</span>
<span class="fc" id="L59">			final int opsize=ostack.size();</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">			for(int j=opsize-count; j&lt;opsize; j++)</span>
<span class="fc" id="L61">				ostack.push(ostack.get(j));</span>
<span class="fc" id="L62">		};</span>

	/**
	*	Context action of the {@code countdictstack} operator.
	*/
	@OperatorType(&quot;countdictstack&quot;)
<span class="fc" id="L68">	public static final ContextAction PSY_COUNTDICTSTACK=oContext-&gt;</span>
<span class="fc" id="L69">		oContext.operandStack().push(PsyInteger.of(oContext.dictStack().size()));</span>

	/**
	*	Context action of the {@code countexecstack} operator.
	*/
	@OperatorType(&quot;countexecstack&quot;)
<span class="fc" id="L75">	public static final ContextAction PSY_COUNTEXECSTACK=oContext-&gt;</span>
<span class="fc" id="L76">		oContext.operandStack().push(PsyInteger.of(oContext.executionStack().size()));</span>

	/**
	*	Context action of the {@code countstack} operator.
	*/
	@OperatorType(&quot;countstack&quot;)
<span class="fc" id="L82">	public static final ContextAction PSY_COUNTSTACK=oContext-&gt;</span>
		{
<span class="fc" id="L84">			final var ostack=oContext.operandStack();</span>
<span class="fc" id="L85">			ostack.push(PsyInteger.of(ostack.size()));</span>
<span class="fc" id="L86">		};</span>

	/**
	*	Context action of the {@code counttomark} operator.
	*/
	@OperatorType(&quot;counttomark&quot;)
<span class="fc" id="L92">	public static final ContextAction PSY_COUNTTOMARK=oContext-&gt;</span>
		{
<span class="fc" id="L94">			final var ostack=oContext.operandStack();</span>
<span class="fc" id="L95">			ostack.push(PsyInteger.of(-ostack.findMarkPosition()-1+ostack.size()));</span>
<span class="fc" id="L96">		};</span>

	/**
	*	Context action of the {@code currentcontext} operator.
	*/
	@OperatorType(&quot;currentcontext&quot;)
<span class="fc" id="L102">	public static final ContextAction PSY_CURRENTCONTEXT=oContext-&gt;</span>
<span class="nc" id="L103">		oContext.operandStack().push(oContext);</span>

	/**
	*	Context action of the {@code currentdict} operator.
	*/
	@OperatorType(&quot;currentdict&quot;)
<span class="fc" id="L109">	public static final ContextAction PSY_CURRENTDICT=oContext-&gt;</span>
		{
<span class="fc" id="L111">			final var ostack=oContext.operandStack();</span>
<span class="fc" id="L112">			ostack.push(oContext.currentDict());</span>
<span class="fc" id="L113">		};</span>

	/**
	*	Context action of the {@code def} operator.
	*/
	@OperatorType(&quot;def&quot;)
<span class="fc" id="L119">	public static final ContextAction PSY_DEF=oContext-&gt;</span>
		{
<span class="fc" id="L121">			final var ostack=oContext.operandStackBacked(2);</span>
<span class="fc" id="L122">			final var oName=ostack.&lt;PsyString&gt;getBacked(0);</span>
<span class="fc" id="L123">			final var name=oName.stringValue();</span>
<span class="fc" id="L124">			final var o=ostack.getBacked(1);</span>
<span class="fc" id="L125">			final var prefixOffset=name.indexOf('@');</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">			if(prefixOffset==-1)</span>
<span class="fc" id="L127">				oContext.currentDict().psyPut(oName, o);</span>
			else
<span class="fc" id="L129">				oContext.namespacePool().get(name.substring(0, prefixOffset))</span>
<span class="fc" id="L130">					.put(name.substring(prefixOffset+1), o);</span>
<span class="fc" id="L131">		};</span>

	/**
	*	Context action of the {@code dictstack} operator.
	*/
	@OperatorType(&quot;dictstack&quot;)
<span class="fc" id="L137">	public static final ContextAction PSY_DICTSTACK=oContext-&gt;</span>
<span class="nc" id="L138">		oContext.operandStack().push(new PsyArray(new ArrayList&lt;PsyObject&gt;(oContext.dictStack().clone())));</span>

	/**
	*	Context action of the {@code dup} operator.
	*/
	@OperatorType(&quot;dup&quot;)
<span class="fc" id="L144">	public static final ContextAction PSY_DUP=oContext-&gt;</span>
		{
<span class="fc" id="L146">			final var ostack=oContext.operandStack();</span>
<span class="fc" id="L147">			ostack.ensureSize(1);</span>
<span class="fc" id="L148">			ostack.push(ostack.peek());</span>
<span class="fc" id="L149">		};</span>

	/**
	*	Context action of the {@code editline} operator.
	*/
	@OperatorType(&quot;editline&quot;)
<span class="fc" id="L155">	public static final ContextAction PSY_EDITLINE=oContext-&gt;</span>
		{
			try
			{
<span class="nc" id="L159">				final var ostack=oContext.operandStack();</span>
<span class="nc" id="L160">				final var consoleReader=new ConsoleReader();</span>
<span class="nc" id="L161">				final var line=consoleReader.readLine();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">				if(line!=null)</span>
<span class="nc" id="L163">					ostack.push(new PsyString(line+&quot;\n&quot;));</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">				ostack.push(PsyBoolean.of(line!=null));</span>
			}
<span class="nc" id="L166">			catch(final IOException ex)</span>
			{
<span class="nc" id="L168">				throw new PsyIOErrorException();</span>
<span class="nc" id="L169">			}</span>
<span class="nc" id="L170">		};</span>

	/**
	*	Context action of the {@code end} operator.
	*/
	@OperatorType(&quot;end&quot;)
<span class="fc" id="L176">	public static final ContextAction PSY_END=oContext-&gt;oContext.dictStack().end();</span>

	/**
	*	Context action of the {@code exch} operator.
	*/
	@OperatorType(&quot;exch&quot;)
<span class="fc" id="L182">	public static final ContextAction PSY_EXCH=oContext-&gt;</span>
		{
<span class="fc" id="L184">			final var ostack=oContext.operandStackBacked(2);</span>
<span class="fc" id="L185">			ostack.push(ostack.getBacked(1));</span>
<span class="fc" id="L186">			ostack.push(ostack.getBacked(0));</span>
<span class="fc" id="L187">		};</span>

	/**
	*	Context action of the {@code exec} operator.
	*/
	@OperatorType(&quot;exec&quot;)
<span class="fc" id="L193">	public static final ContextAction PSY_EXEC=oContext-&gt;</span>
<span class="fc" id="L194">		oContext.operandStackBacked(1).getBacked(0).invoke(oContext);</span>

	/**
	*	Context action of the {@code execstack} operator.
	*/
	@OperatorType(&quot;execstack&quot;)
<span class="fc" id="L200">	public static final ContextAction PSY_EXECSTACK=oContext-&gt;</span>
<span class="fc" id="L201">		oContext.operandStack().push(new PsyArray((ArrayList&lt;PsyObject&gt;)oContext.executionStack().clone()));</span>

	/**
	*	Context action of the {@code executive} operator.
	*/
	@OperatorType(&quot;executive&quot;)
<span class="pc" id="L207">	public static final ContextAction PSY_EXECUTIVE=oContext-&gt;oContext.repl();</span>

	/**
	*	Context action of the {@code exit} operator.
	*/
	@OperatorType(&quot;exit&quot;)
<span class="fc" id="L213">	public static final ContextAction PSY_EXIT=oContext-&gt;</span>
<span class="fc" id="L214">			oContext.executionStack().exitLoop();</span>

	/**
	*	Context action of the {@code for} operator.
	*/
	@OperatorType(&quot;for&quot;)
<span class="fc" id="L220">	public static final ContextAction PSY_FOR=oContext-&gt;</span>
		{
<span class="fc" id="L222">			final var ostack=oContext.operandStackBacked(4);</span>
<span class="fc" id="L223">			final var estack=oContext.executionStack();</span>
<span class="fc" id="L224">			final PsyRealNumeric oInitial=ostack.getBacked(0);</span>
<span class="fc" id="L225">			final PsyRealNumeric oIncrement=ostack.getBacked(1);</span>
<span class="fc" id="L226">			final PsyRealNumeric oLimit=ostack.getBacked(2);</span>
<span class="fc" id="L227">			final PsyObject oProc=ostack.getBacked(3);</span>

<span class="fc" id="L229">			oContext.executionStack().enterLoop();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">			estack.push(oIncrement.compareTo(PsyInteger.ZERO)&gt;0?</span>
<span class="fc" id="L231">				new PsyOperator(&quot;#for_continue&quot;)</span>
<span class="fc" id="L232">					{</span>
<span class="fc" id="L233">						private PsyRealNumeric oCounter=oInitial;</span>

						@Override
						public void perform(final PsyContext oContext)
							throws PsyInvalidExitException
						{
<span class="fc bfc" id="L239" title="All 2 branches covered.">							if(oCounter.compareTo(oLimit)&gt;0)</span>
<span class="fc" id="L240">								oContext.executionStack().exitLoop();</span>
							else
							{
<span class="fc" id="L243">								estack.push(this);</span>
<span class="fc" id="L244">								ostack.push(oCounter);</span>
<span class="fc" id="L245">								oCounter=oCounter.psyAdd(oIncrement);</span>
<span class="fc" id="L246">								oProc.invoke(oContext);</span>
							}
<span class="fc" id="L248">						}</span>
					}:
<span class="fc" id="L250">				new PsyOperator(&quot;#for_continue&quot;)</span>
<span class="fc" id="L251">					{</span>
<span class="fc" id="L252">						private PsyRealNumeric oCounter=oInitial;</span>

						@Override
						public void perform(final PsyContext oContext)
							throws PsyInvalidExitException
						{
<span class="fc bfc" id="L258" title="All 2 branches covered.">							if(oCounter.compareTo(oLimit)&lt;0)</span>
<span class="fc" id="L259">								oContext.executionStack().exitLoop();</span>
							else
							{
<span class="fc" id="L262">								estack.push(this);</span>
<span class="fc" id="L263">								ostack.push(oCounter);</span>
<span class="fc" id="L264">								oCounter=oCounter.psyAdd(oIncrement);</span>
<span class="fc" id="L265">								oProc.invoke(oContext);</span>
							}
<span class="fc" id="L267">						}</span>
					});
<span class="fc" id="L269">			};</span>

	/**
	*	Context action of the {@code fork} operator.
	*/
	@OperatorType(&quot;fork&quot;)
<span class="fc" id="L275">	public static final ContextAction PSY_FORK=oContext-&gt;oContext.fork();</span>

	/**
	*	Context action of the {@code halt} operator.
	*/
	@OperatorType(&quot;halt&quot;)
<span class="fc" id="L281">	public static final ContextAction PSY_HALT=oContext-&gt;</span>
		{
<span class="nc" id="L283">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="nc" id="L284">			System.exit(ostack.&lt;PsyInteger&gt;getBacked(0).intValue());</span>
<span class="nc" id="L285">		};</span>

	/**
	*	Context action of the {@code if} operator.
	*/
	@OperatorType(&quot;if&quot;)
<span class="fc" id="L291">	public static final ContextAction PSY_IF=oContext-&gt;</span>
		{
<span class="fc" id="L293">			final var ostack=oContext.operandStackBacked(2);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">			if(ostack.&lt;PsyBoolean&gt;getBacked(0).booleanValue())</span>
<span class="fc" id="L295">				ostack.getBacked(1).invoke(oContext);</span>
<span class="fc" id="L296">		};</span>

	/**
	*	Context action of the {@code ifelse} operator.
	*/
	@OperatorType(&quot;ifelse&quot;)
<span class="fc" id="L302">	public static final ContextAction PSY_IFELSE=oContext-&gt;</span>
		{
<span class="fc" id="L304">			final var ostack=oContext.operandStackBacked(3);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			ostack.getBacked(ostack.&lt;PsyBoolean&gt;getBacked(0).booleanValue()? 1: 2)</span>
<span class="fc" id="L306">				.invoke(oContext);</span>
<span class="fc" id="L307">		};</span>

	/**
	*	Context action of the {@code index} operator.
	*/
	@OperatorType(&quot;index&quot;)
<span class="fc" id="L313">	public static final ContextAction PSY_INDEX=oContext-&gt;</span>
		{
<span class="fc" id="L315">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L316">			final int index=ostack.&lt;PsyInteger&gt;getBacked(0).intValue();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">			if(index&lt;0)</span>
<span class="fc" id="L318">				throw new PsyRangeCheckException();</span>
<span class="fc" id="L319">			ostack.ensureSize(index+1);</span>
<span class="fc" id="L320">			ostack.push(ostack.get(ostack.size()-index-1));</span>
<span class="fc" id="L321">		};</span>

	/**
	*	Context action of the {@code join} operator.
	*/
	@OperatorType(&quot;join&quot;)
<span class="fc" id="L327">	public static final ContextAction PSY_JOIN=oContext-&gt;</span>
		{
<span class="fc" id="L329">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L330">			final var oContextJoining=ostack.&lt;PsyContext&gt;getBacked(0);</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">			if(oContextJoining==oContext)</span>
<span class="nc" id="L332">				throw new PsyInvalidContextException();</span>
			try
			{
<span class="fc" id="L335">				oContextJoining.join();</span>
			}
<span class="nc" id="L337">			catch(final InterruptedException ex)</span>
			{
<span class="nc" id="L339">				throw new PsyInterruptException();</span>
<span class="fc" id="L340">			}</span>
<span class="fc" id="L341">			final var ostackJoining=oContextJoining.operandStack();</span>
<span class="fc" id="L342">			ostack.push(PsyMark.MARK);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">			for(final var o: ostackJoining)</span>
<span class="nc" id="L344">				ostack.push(o);</span>
<span class="fc" id="L345">		};</span>

	/**
	*	Context action of the {@code load} operator.
	*/
	@OperatorType(&quot;load&quot;)
<span class="fc" id="L351">	public static final ContextAction PSY_LOAD=oContext-&gt;</span>
		{
<span class="fc" id="L353">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L354">			ostack.push(oContext.psyLoad(ostack.getBacked(0)));</span>
<span class="fc" id="L355">		};</span>

	/**
	*	Context action of the {@code loop} operator.
	*/
	@OperatorType(&quot;loop&quot;)
<span class="fc" id="L361">	public static final ContextAction PSY_LOOP=oContext-&gt;</span>
		{
<span class="fc" id="L363">			final var oProc=oContext.operandStackBacked(1).getBacked(0);</span>
<span class="fc" id="L364">			oContext.executionStack().enterLoop();</span>
<span class="fc" id="L365">			oContext.executionStack().push(new PsyOperator(&quot;#loop_continue&quot;)</span>
<span class="fc" id="L366">				{</span>
					@Override
					public void perform(final PsyContext oContext1)
						throws PsyErrorException
					{
<span class="fc" id="L371">						oContext1.executionStack().push(this);</span>
<span class="fc" id="L372">						oProc.invoke(oContext1);</span>
<span class="fc" id="L373">					}</span>
				});
<span class="fc" id="L375">		};</span>

	/**
	*	Context action of the {@code namespace} operator.
	*/
	@OperatorType(&quot;namespace&quot;)
<span class="fc" id="L381">	public static final ContextAction PSY_NAMESPACE=oContext-&gt;</span>
		{
<span class="fc" id="L383">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L384">			ostack.push(oContext.namespacePool().get(ostack.&lt;PsyTextual&gt;getBacked(0).stringValue()));</span>
<span class="fc" id="L385">		};</span>

	/**
	*	Context action of the {@code pop} operator.
	*/
	@OperatorType(&quot;pop&quot;)
<span class="fc" id="L391">	public static final ContextAction PSY_POP=</span>
<span class="fc" id="L392">		ContextAction.&lt;PsyObject&gt;ofConsumer(o-&gt;{});</span>

	/**
	*	Context action of the {@code prettyprint} operator.
	*/
	@OperatorType(&quot;prettyprint&quot;)
<span class="fc" id="L398">	public static final ContextAction PSY_PRETTYPRINT=oContext-&gt;</span>
		{
<span class="fc" id="L400">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L401">			final var oStdWriter=(PsyWriter)oContext.dictStack().load(&quot;stdout&quot;);</span>
<span class="fc" id="L402">			oStdWriter.psyWriteString(ostack.getBacked(0).psySyntax());</span>
<span class="fc" id="L403">			oStdWriter.psyWriteString(oContext.dictStack().load(&quot;eol&quot;));</span>
<span class="fc" id="L404">			oStdWriter.psyFlush();</span>
<span class="fc" id="L405">		};</span>

	/**
	*	Context action of the {@code print} operator.
	*/
	@OperatorType(&quot;print&quot;)
<span class="fc" id="L411">	public static final ContextAction PSY_PRINT=oContext-&gt;</span>
		{
<span class="fc" id="L413">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L414">			oContext.dictStack().&lt;PsyWriter&gt;load(&quot;stdout&quot;).psyWriteString(ostack.getBacked(0));</span>
<span class="fc" id="L415">		};</span>

	/**
	*	Context action of the {@code quit} operator.
	*/
	@OperatorType(&quot;quit&quot;)
<span class="fc" id="L421">	public static final ContextAction PSY_QUIT=oContext-&gt;oContext.quit();</span>

	/**
	*	Context action of the {@code repeat} operator.
	*/
	@OperatorType(&quot;repeat&quot;)
<span class="fc" id="L427">	public static final ContextAction PSY_REPEAT=oContext-&gt;</span>
		{
<span class="fc" id="L429">			final var ostack=oContext.operandStackBacked(2);</span>
<span class="fc" id="L430">			final var estack=oContext.executionStack();</span>
<span class="fc" id="L431">			final PsyInteger oCount=ostack.getBacked(0);</span>
<span class="fc" id="L432">			final PsyObject oProc=ostack.getBacked(1);</span>
<span class="fc" id="L433">			final long count=oCount.longValue();</span>

<span class="fc bfc" id="L435" title="All 2 branches covered.">			if(count&lt;0)</span>
<span class="fc" id="L436">				throw new PsyRangeCheckException();</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">			if(count==0)</span>
<span class="fc" id="L438">				return;</span>

<span class="fc" id="L440">			oContext.executionStack().enterLoop();</span>
<span class="fc" id="L441">			oContext.executionStack().push(new PsyOperator(&quot;#repeat_continue&quot;)</span>
<span class="fc" id="L442">				{</span>
<span class="fc" id="L443">					private long count1=count;</span>

					@Override
					public void perform(final PsyContext oContext1)
						throws PsyInvalidExitException
					{
<span class="fc bfc" id="L449" title="All 2 branches covered.">						if(count1--==0)</span>
<span class="fc" id="L450">							oContext1.executionStack().exitLoop();</span>
						else
						{
<span class="fc" id="L453">							estack.push(this);</span>
<span class="fc" id="L454">							oProc.invoke(oContext1);</span>
						}
<span class="fc" id="L456">					}</span>
				});
<span class="fc" id="L458">		};</span>

	/**
	*	Context action of the {@code require} operator.
	*/
	@OperatorType(&quot;require&quot;)
<span class="fc" id="L464">	public static final ContextAction PSY_REQUIRE=oContext-&gt;</span>
		{
			// TODO
<span class="fc" id="L467">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L468">			oContext.psyRequire(ostack.getBacked(0));</span>
<span class="fc" id="L469">		};</span>

	/**
	*	Context action of the {@code roll} operator.
	*/
	@OperatorType(&quot;roll&quot;)
<span class="fc" id="L475">	public static final ContextAction PSY_ROLL=oContext-&gt;</span>
		{
<span class="fc" id="L477">			final var ostack=oContext.operandStackBacked(2);</span>
<span class="fc" id="L478">			final var n=ostack.&lt;PsyInteger&gt;getBacked(0).intValue();</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">			if(n&lt;0)</span>
<span class="fc" id="L480">				throw new PsyRangeCheckException();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">			if(n==0)</span>
<span class="fc" id="L482">				return;</span>
<span class="fc" id="L483">			final int j=Math.floorMod(ostack.&lt;PsyInteger&gt;getBacked(1).intValue(), n);</span>
<span class="fc" id="L484">			final var ostackSize=ostack.size();</span>
<span class="fc" id="L485">			ostack.ensureSize(n);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">			for(int i=0; i&lt;j; i++)</span>
<span class="fc" id="L487">				ostack.add(ostackSize-n, ostack.pop());</span>
<span class="fc" id="L488">		};</span>

	/**
	*	Context action of the {@code say} operator.
	*/
	@OperatorType(&quot;say&quot;)
<span class="fc" id="L494">	public static final ContextAction PSY_SAY=oContext-&gt;</span>
		{
<span class="nc" id="L496">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="nc" id="L497">			final var stdwriter=(PsyWriter)oContext.dictStack().load(&quot;stdout&quot;);</span>
<span class="nc" id="L498">			stdwriter.psyWriteString(ostack.getBacked(0));</span>
<span class="nc" id="L499">			stdwriter.psyWriteString((PsyString)oContext.dictStack().load(&quot;eol&quot;));</span>
<span class="nc" id="L500">			stdwriter.psyFlush();</span>
<span class="nc" id="L501">		};</span>

	/**
	*	Context action of the {@code sleep} operator.
	*/
	@OperatorType(&quot;sleep&quot;)
<span class="fc" id="L507">	public static final ContextAction PSY_SLEEP=oContext-&gt;</span>
		{
			try
			{
<span class="fc" id="L511">				Thread.sleep(oContext.operandStackBacked(1).&lt;PsyInteger&gt;getBacked(0).longValue());</span>
			}
<span class="fc" id="L513">			catch(final IllegalArgumentException ex)</span>
			{
<span class="fc" id="L515">				throw new PsyRangeCheckException();</span>
			}
<span class="nc" id="L517">			catch(final InterruptedException ex)</span>
			{
<span class="nc" id="L519">				throw new PsyInterruptException();</span>
<span class="fc" id="L520">			}</span>
<span class="fc" id="L521">		};</span>

	/**
	*	Context action of the {@code stack} operator.
	*/
	@OperatorType(&quot;stack&quot;)
<span class="fc" id="L527">	public static final ContextAction PSY_STACK=oContext-&gt;</span>
		{
<span class="fc" id="L529">			final var ostack=oContext.operandStack();</span>
<span class="fc" id="L530">			ostack.push(new PsyArray((ArrayList&lt;PsyObject&gt;)ostack.clone()));</span>
<span class="fc" id="L531">		};</span>

	/**
	*	Context action of the {@code stop} operator.
	*/
	@OperatorType(&quot;stop&quot;)
<span class="fc" id="L537">	public static final ContextAction PSY_STOP=PsyContext::stop_;</span>

	/**
	*	Context action of the {@code stopped} operator.
	*/
	@OperatorType(&quot;stopped&quot;)
<span class="fc" id="L543">	public static final ContextAction PSY_STOPPED=oContext-&gt;</span>
		{
<span class="fc" id="L545">			oContext.executionStack().push(new PsyOperator(&quot;#stopped_continue&quot;)</span>
<span class="fc" id="L546">				{</span>
					@Override
					public void perform(final PsyContext oContext1)
					{
<span class="fc" id="L550">						oContext1.operandStack().push(PsyBoolean.of(oContext1.getStopped()));</span>
<span class="fc" id="L551">						oContext1.setStopped(false);</span>
<span class="fc" id="L552">						oContext1.executionStack().exitStop();</span>
<span class="fc" id="L553">					}</span>
				});
<span class="fc" id="L555">			oContext.executionStack().enterStop();</span>
<span class="fc" id="L556">			oContext.operandStackBacked(1).getBacked(0).invoke(oContext);</span>
<span class="fc" id="L557">		};</span>
	/**
	*	Context action of the {@code store} operator.
	*/
	@OperatorType(&quot;store&quot;)
<span class="fc" id="L562">	public static final ContextAction PSY_STORE=oContext-&gt;</span>
		{
<span class="nc" id="L564">			final var ostack=oContext.operandStackBacked(2);</span>
<span class="nc" id="L565">			oContext.dictStack().store(ostack.getBacked(0), ostack.getBacked(1));</span>
<span class="nc" id="L566">		};</span>

	/**
	*	Context action of the {@code tokens} operator.
	*/
	@OperatorType(&quot;tokens&quot;)
<span class="fc" id="L572">	public static final ContextAction PSY_TOKENS=oContext-&gt;</span>
		{
<span class="nc" id="L574">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="nc" id="L575">			oContext.interpretBraced(new PsyStringReader(ostack.&lt;PsyName&gt;getBacked(0)));</span>
<span class="nc" id="L576">		};</span>

	/**
	*	Context action of the {@code warn} operator.
	*/
	@OperatorType(&quot;warn&quot;)
<span class="fc" id="L582">	public static final ContextAction PSY_WARN=oContext-&gt;</span>
		{
<span class="fc" id="L584">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L585">			final PsyWriter stderror=oContext.dictStack().load(&quot;stderr&quot;);</span>
<span class="fc" id="L586">			stderror.psyWriteString(ostack.getBacked(0));</span>
<span class="fc" id="L587">			stderror.psyFlush();</span>
<span class="fc" id="L588">		};</span>

	/**
	*	Context action of the {@code where} operator.
	*/
	@OperatorType(&quot;where&quot;)
<span class="fc" id="L594">	public static final ContextAction PSY_WHERE=oContext-&gt;</span>
		{
<span class="fc" id="L596">			final var ostack=oContext.operandStackBacked(1);</span>
<span class="fc" id="L597">			ostack.pushOptional(oContext.psyWhere(ostack.&lt;PsyTextual&gt;getBacked(0)));</span>
<span class="fc" id="L598">		};</span>

	/**
	*	Context action of the {@code yield} operator.
	*/
	@OperatorType(&quot;yield&quot;)
<span class="pc" id="L604">	public static final ContextAction PSY_YIELD=oContext-&gt;Thread.yield();</span>

	public void showStacks();

	public long getId();

	public void join()
		throws InterruptedException;

	@Override
	public default String toSyntaxString()
	{
<span class="nc" id="L616">		return &quot;%context=&quot;+getId()+&quot;%&quot;;</span>
	}

	/**
	*	{@return the currently executing context}
	*/
	public default PsyContext psyCurrentContext()
	{
<span class="nc" id="L624">		return this;</span>
	}

	public void fork()
		throws PsyStackUnderflowException, PsyUnmatchedMarkException;

	public void quit();

	public void stop_();

	/**
	*	{@return the operand stack}
	*/
	public OperandStack operandStack();

	/**
	*	{@return the dictionary stack}
	*/
	public DictStack dictStack();

	/**
	*	{@return the execution stack}
	*/
	public ExecutionStack executionStack();

	/**
	*	{@return the system dictionary}
	*/
	public PsyFormalDict&lt;PsyObject&gt; systemDict();

	/**
	*	{@return the user dictionary}
	*/
	public PsyFormalDict&lt;PsyObject&gt; userDict();

	/**
	*	{@return the current dictionary (the topmost on the dictionary stack)}
	*/
	public PsyFormalDict&lt;PsyObject&gt; currentDict();

	/**
	*	{@return the namespace pool}
	*/
	public NamespacePool namespacePool();

	/**
	*	{@return the size of the execution stack}
	*/
	public int execLevel();

	public void repl()
		throws PsyErrorException;

	/**
	*	{@return the value of the stopped flag}
	*/
	public boolean getStopped();

	/**
	*	Sets the stopped flag to the specified value.
	*
	*	@param stopFlag the value of the stopped flag.
	*/
	public void setStopped(final boolean stopFlag);

	public void handleExecutionStack(final int level);

	/**
	*	Interprets the Psylla code from the {@code reader} object.
	*
	*	@param oReader the {@code reader} object.
	*/
	public void interpret(final PsyReader oReader);

	public void interpretBraced(final PsyReader oReader)
		throws PsyErrorException;

	public OperandStack operandStackBacked(final int count)
		throws PsyStackUnderflowException;

	public default Optional&lt;PsyFormalDict&lt;PsyObject&gt;&gt; psyWhere(final PsyTextual oKey)
	{
<span class="fc" id="L706">		return dictStack().where(oKey.stringValue());</span>
	}

	public &lt;T extends PsyObject&gt; T psyLoad(final PsyTextual oKey)
		throws PsyUndefinedException;

	public void psyRequire(final PsyTextual o)
		throws PsyErrorException;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202410190809</span></div></body></html>