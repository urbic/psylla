<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PsyArray.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Psylla v0.22.1</a> &gt; <a href="index.source.html" class="el_package">coneforest.psylla.core</a> &gt; <span class="el_source">PsyArray.java</span></div><h1>PsyArray.java</h1><pre class="source lang-java linenums">package coneforest.psylla.core;

import coneforest.psylla.runtime.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;

/**
*	The representation of {@code array}.
*/
@Type(&quot;array&quot;)
public class PsyArray
	implements PsyFormalArray&lt;PsyObject&gt;
{
	/**
	*	Context action of the {@code array} operator.
	*/
	@OperatorType(&quot;array&quot;)
<span class="fc" id="L19">	public static final ContextAction PSY_ARRAY</span>
<span class="fc" id="L20">		=ContextAction.ofSupplier(PsyArray::new);</span>

	/**
	*	Context action of the {@code arraytomark} operator.
	*/
	@OperatorType(&quot;arraytomark&quot;)
<span class="fc" id="L26">	public static final ContextAction PSY_ARRAYTOMARK=oContext-&gt;</span>
		{
<span class="fc" id="L28">			final var ostack=oContext.operandStack();</span>
<span class="fc" id="L29">			final var i=ostack.findMarkPosition();</span>
<span class="fc" id="L30">			final var oArray=new PsyArray();</span>
<span class="fc bfc" id="L31" title="All 2 branches covered.">			for(int j=i+1; j&lt;ostack.size(); j++)</span>
<span class="fc" id="L32">				oArray.psyAppend(ostack.get(j));</span>
<span class="fc" id="L33">			ostack.setSize(i);</span>
<span class="fc" id="L34">			ostack.push(oArray);</span>
<span class="fc" id="L35">		};</span>

	/**
	*	Context action of the {@code binarysearch} operator.
	*/
	@OperatorType(&quot;binarysearch&quot;)
<span class="fc" id="L41">	public static final ContextAction PSY_BINARYSEARCH=oContext-&gt;</span>
		{
<span class="fc" id="L43">			final var ostack=oContext.operandStackBacked(3);</span>
<span class="fc" id="L44">			final var oIndex=ostack.&lt;PsyArray&gt;getBacked(0).psyBinarySearch(</span>
<span class="fc" id="L45">					ostack.getBacked(1), ostack.getBacked(2), oContext);</span>
<span class="fc" id="L46">			final var index=oIndex.intValue();</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">			if(index&gt;=0)</span>
			{
<span class="fc" id="L49">				ostack.push(oIndex);</span>
<span class="fc" id="L50">				ostack.push(PsyBoolean.TRUE);</span>
			}
			else
			{
<span class="fc" id="L54">				ostack.push(PsyInteger.of(-index-1));</span>
<span class="fc" id="L55">				ostack.push(PsyBoolean.FALSE);</span>
			}
<span class="fc" id="L57">		};</span>

	/**
	*	Context action of the {@code sort} operator.
	*/
	@OperatorType(&quot;sort&quot;)
<span class="fc" id="L63">	public static final ContextAction PSY_SORT=oContext-&gt;</span>
		{
<span class="fc" id="L65">			final var ostack=oContext.operandStackBacked(2);</span>
<span class="fc" id="L66">			ostack.&lt;PsyArray&gt;getBacked(0).psySort(ostack.getBacked(1), oContext);</span>
<span class="fc" id="L67">		};</span>

	protected final ArrayList&lt;PsyObject&gt; array;

	/**
	*	Constructs a new empty {@code array}.
	*/
	public PsyArray()
	{
<span class="fc" id="L76">		this(new ArrayList&lt;PsyObject&gt;());</span>
<span class="fc" id="L77">	}</span>

	/**
	*	Constructs a new {@code array} wrapped around the given array list.
	*
	*	@param array a given array list.
	*/
	public PsyArray(final ArrayList&lt;PsyObject&gt; array)
<span class="fc" id="L85">	{</span>
<span class="fc" id="L86">		this.array=array;</span>
<span class="fc" id="L87">	}</span>

	@Override
	public int length()
	{
<span class="fc" id="L92">		return array.size();</span>
	}

	@Override
	public Iterator&lt;PsyObject&gt; iterator()
	{
<span class="fc" id="L98">		return array.iterator();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public PsyArray psyClone()
	{
<span class="fc" id="L105">		return new PsyArray((ArrayList&lt;PsyObject&gt;)array.clone());</span>
	}

	@Override
	public PsyObject get(final int index)
		throws PsyRangeCheckException
	{
		try
		{
<span class="fc bfc" id="L114" title="All 2 branches covered.">			return array.get(index&lt;0? index+length(): index);</span>
		}
<span class="fc" id="L116">		catch(final IndexOutOfBoundsException e)</span>
		{
<span class="fc" id="L118">			throw new PsyRangeCheckException();</span>
		}
	}

	@Override
	public PsyArray psyGetInterval(final PsyInteger oStart, final PsyInteger oCount)
		throws PsyRangeCheckException
	{
		try
		{
<span class="fc" id="L128">			return new PsyArray(new ArrayList&lt;PsyObject&gt;(array.subList(oStart.intValue(),</span>
<span class="fc" id="L129">					oStart.intValue()+oCount.intValue())));</span>
		}
<span class="nc" id="L131">		catch(final IndexOutOfBoundsException|IllegalArgumentException e)</span>
		{
<span class="nc" id="L133">			throw new PsyRangeCheckException();</span>
		}
	}

	@Override
	public void psyAppend(final PsyObject o)
		throws PsyLimitCheckException
	{
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">		if(length()==Integer.MAX_VALUE)</span>
<span class="nc" id="L142">			throw new PsyLimitCheckException();</span>
<span class="fc" id="L143">		array.add(o);</span>
<span class="fc" id="L144">	}</span>

	@Override
	public void insert(final int indexValue, final PsyObject o)
		throws PsyRangeCheckException
	{
		try
		{
<span class="fc bfc" id="L152" title="All 2 branches covered.">			array.add(indexValue&lt;0? indexValue+length(): indexValue, o);</span>
		}
<span class="fc" id="L154">		catch(final IndexOutOfBoundsException e)</span>
		{
<span class="fc" id="L156">			throw new PsyRangeCheckException();</span>
<span class="fc" id="L157">		}</span>
<span class="fc" id="L158">	}</span>

	@Override
	public void put(final int indexValue, final PsyObject o)
		throws PsyRangeCheckException
	{
		try
		{
<span class="fc bfc" id="L166" title="All 2 branches covered.">			array.set(indexValue&lt;0? indexValue+length(): indexValue, o);</span>
		}
<span class="fc" id="L168">		catch(final IndexOutOfBoundsException e)</span>
		{
<span class="fc" id="L170">			throw new PsyRangeCheckException();</span>
<span class="fc" id="L171">		}</span>
<span class="fc" id="L172">	}</span>

	@Override
	public void delete(final int indexValue)
		throws PsyRangeCheckException
	{
		try
		{
<span class="fc" id="L180">			array.remove(indexValue);</span>
		}
<span class="fc" id="L182">		catch(final IndexOutOfBoundsException e)</span>
		{
<span class="fc" id="L184">			throw new PsyRangeCheckException();</span>
<span class="fc" id="L185">		}</span>
<span class="fc" id="L186">	}</span>

	@Override
	public PsyObject extract(final int indexValue)
		throws PsyRangeCheckException
	{
		try
		{
<span class="fc bfc" id="L194" title="All 2 branches covered.">			return array.remove(indexValue&lt;0? indexValue+length(): indexValue);</span>
		}
<span class="fc" id="L196">		catch(final IndexOutOfBoundsException e)</span>
		{
<span class="fc" id="L198">			throw new PsyRangeCheckException();</span>
		}
	}

	@Override
	public PsyArray psyExtractInterval(final PsyInteger oStart, final PsyInteger oCount)
		throws PsyRangeCheckException
	{
<span class="nc" id="L206">		final var oResult=psyGetInterval(oStart, oCount);</span>
<span class="nc" id="L207">		array.subList(oStart.intValue(), oStart.intValue()+oCount.intValue()).clear();</span>
<span class="nc" id="L208">		return oResult;</span>
	}

	@Override
	public PsyArray psySlice(final PsyIterable&lt;PsyInteger&gt; oIndices)
		throws PsyRangeCheckException, PsyLimitCheckException
	{
<span class="nc" id="L215">		final var oValues=new PsyArray();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">		for(final var oIndex: oIndices)</span>
<span class="nc" id="L217">			oValues.psyAppend(psyGet(oIndex));</span>
<span class="nc" id="L218">		return oValues;</span>
	}

	@Override
	public void psyClear()
	{
<span class="fc" id="L224">		array.clear();</span>
<span class="fc" id="L225">	}</span>

	@Override
	public void psySetLength(final PsyInteger oLength)
		throws PsyRangeCheckException, PsyLimitCheckException
	{
<span class="fc" id="L231">		final var length=oLength.longValue();</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">		if(length&lt;0)</span>
<span class="fc" id="L233">			throw new PsyRangeCheckException();</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">		if(length&gt;Integer.MAX_VALUE)</span>
<span class="fc" id="L235">			throw new PsyLimitCheckException();</span>
<span class="fc" id="L236">		int i=length();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">		if(length&lt;i)</span>
<span class="fc" id="L238">			array.subList((int)length, i).clear();</span>
		else
		{
<span class="fc" id="L241">			array.ensureCapacity((int)length);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">			while(i++&lt;length)</span>
<span class="fc" id="L243">				array.add(PsyNull.NULL);</span>
		}
<span class="fc" id="L245">	}</span>

	/**
	*	Sorts this list according to the order induced by the specified comparator. The sort is
	*	stable: this method must not reorder equal elements.
	*
	*	@param oComparator the {@code proc} comparator used to compare array elements.
	*	@param oContext the execution context.
	*/
	public void psySort(final PsyProc oComparator, final PsyContext oContext)
	{
<span class="fc" id="L256">		array.sort(oComparator.asComparator(oContext));</span>
<span class="fc" id="L257">	}</span>

	/**
	*	Searches this array for the specified value using the binary search algorithm. The array
	*	must be sorted into ascending order according to the specified comparator. TODO
	*
	*	@param o the value to be searched for.
	*	@param oComparator the comparator by which the array is ordered.
	*	@param oContext the execution context.
	*	@return TODO
	*/
	public PsyInteger psyBinarySearch(final PsyObject o, final PsyProc oComparator, final PsyContext oContext)
	{
<span class="fc" id="L270">		return PsyInteger.of(Collections.&lt;PsyObject&gt;binarySearch(array, o,</span>
<span class="fc" id="L271">				oComparator.asComparator(oContext)));</span>
	}

	@Override
	public PsyStream psyStream()
	{
<span class="fc" id="L277">		return new PsyStream(array.stream());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202410190809</span></div></body></html>